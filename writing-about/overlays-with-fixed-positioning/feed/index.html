<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Overlays with fixed positioning &#8211; Romaric Pascal</title>
	<atom:link href="/writing-about/overlays-with-fixed-positioning/feed/" rel="self" type="application/rss+xml" />
	<link></link>
	<description>Lettering &#38; web development</description>
	<lastBuildDate>Thu, 13 Feb 2020 11:35:45 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.8.13</generator>
	<item>
		<title>Overlays with fixed positioning</title>
		<link>/writing-about/overlays-with-fixed-positioning/</link>
		<pubDate>Wed, 08 Mar 2017 13:09:24 +0000</pubDate>
		<dc:creator><![CDATA[romaricpascal]]></dc:creator>
				<category><![CDATA[CSS]]></category>
		<description><![CDATA[<p><code>position: fixed;</code> is a much older feature of CSS than <a href="/adding-visual-interest-with-css-grid-layout/">CSS grid</a>. Many patterns of modern web applications can be implemented with it, though. It is especially handy when something needs to get overlaid on top of the viewport, without changing <em>where it sits in the HTML</em>.</p>
<h2 id="a-different-kind-of-position-absolute"><a class="headeranchor-link" href="#a-different-kind-of-position-absolute" name="user-content-a-different-kind-of-position-absolute"></a>A different kind of <code>position: absolute</code></h2>
<p>Like <code>position: absolute;</code>, <code>position: fixed;</code> removes the element it is applied to from the flow, collapsing the space it was due to take in the layout. It then positions it according to a combination of <code>top</code>/<code>bottom</code> &amp; <code>left</code>/<code>right</code> offsets. The difference lies in according to what the element will be positioned. <code>position: absolute</code> uses the nearest ancestor whose <code>position</code> is not <code>static</code>. <code>position: fixed</code> uses the viewport, which is what makes it so handy to overlay things. On top of that, as the element is positioned according to the viewport, it’ll stay in position as users scroll the content underneath it.</p>
<h2 id="dialog"><a class="headeranchor-link" href="#dialog" name="user-content-dialog"></a>Dialog</h2>
<p>First thought when it comes to overlaying something is probably displaying a dialog for users to complete a small action. Let’s move the overlay to the center with:</p>
<pre><code class="css">.o-overlay--dialog {
    top: 50%;
    left: 50%;
    tansform: translate(-50%, -50%);
}
</code></pre>
<p>As we just specified two of the positioning offsets, the width and height will grow unconstrained, though. Super long words or a large amount of content might make things end up out of the viewport if we just leave it as is. To avoid that, let’s constrain the width and height a bit.</p>
<pre><code class="css">.o-overlay--dialog {
    /* ... */
    max-width: 100%;
    max-height: 100%;
    overflow: auto;
}
</code></pre>
<p>Voila! A dialog that can appear anywhere in the HTML and still be displayed at the center of the viewport, on top of the content.</p>
<p><iframe src="//jsfiddle.net/rhumaric/1zzfvfem/4/embedded/result,css,html/" width="100%" height="300" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<h2 id="cover"><a class="headeranchor-link" href="#cover" name="user-content-cover"></a>Cover</h2>
<p>Sometimes, you might want to grab users full attention and cover everything. Without unloading the content that’s already there. Setting each offset to 0 will do just that (provided the element doesn’t have any margin).</p>
<pre><code class="css">.o-overlay--cover {
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    margin: 0;
    overflow: auto;
}
</code></pre>
<p><iframe src="//jsfiddle.net/rhumaric/1zzfvfem/5/embedded/result,css,html/" width="100%" height="300" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<h2 id="modal"><a class="headeranchor-link" href="#modal" name="user-content-modal"></a>Modal</h2>
<p>Combining the two previous patterns, we can quickly get a modal window, which will prevent users from clicking/tapping the underlying content.</p>
<p><iframe src="//jsfiddle.net/rhumaric/1zzfvfem/6/embedded/result,css,html/" width="100%" height="300" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<h2 id="side-panels"><a class="headeranchor-link" href="#side-panels" name="user-content-side-panels"></a>Side panels</h2>
<p>If you lose one of the offsets of the cover, you get side panels ready to contain a menu, additional side information or complex form controls. Depending on the content again, you’ll want to restrict the height or width to make sure the content doesn’t just spread over everything. For a left panel, this becomes:</p>
<pre><code class="css">.o-overlay--panelLeft {
  top: 0;
  left: 0;
  bottom: 0;
  overflow: auto;

  max-width: 40%;
}
</code></pre>
<p><iframe src="//jsfiddle.net/rhumaric/1zzfvfem/7/embedded/result,css,html/" width="100%" height="300" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<h2 id="small-notifications"><a class="headeranchor-link" href="#small-notifications" name="user-content-small-notifications"></a>Small notifications</h2>
<p>Add a bit of margin (or more offset) to a panel displayed from the top and you get a nice container for a quick notification. This would enable a form component to completely control the markup of its success message, while displaying where needed to attract some attention.</p>
<pre><code class="css">.o-overlay-toastTop {
  top: 1em;
  left: 1em;
  right: 1em;
}
</code></pre>
<p><iframe src="//jsfiddle.net/rhumaric/1zzfvfem/9/embedded/result,css,html/" width="100%" height="300" frameborder="0" allowfullscreen="allowfullscreen"></iframe></p>
<p>Playing with offsets, margins, and widths, you can get a wide variety of layouts. Vertical toolbars on the side of the viewport, chat windows popping from the bottom come to mind as other examples. These were just a few examples of how fixed positioning can help with some patterns found regularly in modern applications. While they surely could be implemented some other way, <code>position: fixed;</code> has this advantage of displaying things in a different place without touching the markup. A big plus when it comes to keeping things encapsulated. The markup for the modal window used by your custom form component can sit right inside that component, next to the <code>&lt;input&gt;</code> it enhances, rather than having to be appended some way to the <code>&lt;body&gt;</code>. As most techniques, it’s not a silver bullet, but it definitely comes handy. <a href="mailto:hello@romaricpascal.is">Let me know what you think of it!</a></p>
]]></description>
		<guid isPermaLink="false">/?p=561</guid>
		</item>
	</channel>
</rss>
